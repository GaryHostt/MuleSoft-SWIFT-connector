<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns="http://www.mulesoft.org/schema/mule/core"
      xmlns:swift="http://www.mulesoft.org/schema/mule/swift"
      xmlns:http="http://www.mulesoft.org/schema/mule/http"
      xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
      xmlns:file="http://www.mulesoft.org/schema/mule/file"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="
        http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
        http://www.mulesoft.org/schema/mule/swift http://www.mulesoft.org/schema/mule/swift/current/mule-swift.xsd
        http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
        http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd
        http://www.mulesoft.org/schema/mule/file http://www.mulesoft.org/schema/mule/file/current/mule-file.xsd">

    <!-- Configuration Properties -->
    <configuration-properties file="config.properties"/>

    <!-- HTTP Listener Configuration -->
    <http:listener-config name="HTTP_Listener_config">
        <http:listener-connection host="${http.host}" port="${http.port}" />
    </http:listener-config>

    <!-- SWIFT Connector Configuration -->
    <swift:config name="SWIFT_Config">
        <swift:connection 
            host="${swift.host}"
            port="${swift.port}"
            bicCode="${swift.bic}"
            username="${swift.username}"
            password="${swift.password}"
            protocol="FIN"
            enableTls="${swift.enable.tls}"
            autoReconnect="true"
            enableSequenceSync="true">
            
            <!-- âœ… CRITICAL FIX: Reconnection strategy for automatic recovery -->
            <reconnection>
                <reconnect 
                    frequency="5000" 
                    count="3" 
                    blocking="false"/>
            </reconnection>
        </swift:connection>
    </swift:config>

    <!-- File Connector Configuration for Asynchronous Polling -->
    <file:config name="File_Config">
        <file:connection workingDir="${user.home}/Desktop/swift-inbox" />
    </file:config>

    <!-- ==================================== -->
    <!-- API: Send SWIFT Payment (MT103)     -->
    <!-- POST /api/payments                   -->
    <!-- ==================================== -->
    <flow name="send-payment-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/payments" allowedMethods="POST" />
        
        <logger level="INFO" message="Received payment request: #[payload]" />
        
        <!-- Validate input -->
        <choice>
            <when expression="#[payload.amount == null or payload.receiver == null]">
                <set-payload value='{"error": "Missing required fields: amount, receiver"}' />
                <set-variable variableName="httpStatus" value="400" />
            </when>
            <otherwise>
                <!-- Generate correlation ID for tracking -->
                <swift:generate-correlation-id config-ref="SWIFT_Config"
                    businessTransactionId="#[payload.transactionId default uuid()]" />
                
                <set-variable variableName="correlationId" value="#[payload.correlationId]" />
                
                <logger level="INFO" message="Correlation ID: #[vars.correlationId]" />
                
                <!-- Build MT103 message content -->
                <set-payload value="#[
                    ':20:' ++ (payload.reference default uuid()) ++ '\n' ++
                    ':32A:' ++ now() as String {format: 'yyMMdd'} ++ payload.currency ++ payload.amount ++ '\n' ++
                    ':50K:' ++ payload.orderingCustomer ++ '\n' ++
                    ':59:' ++ payload.beneficiary
                ]" />
                
                <!-- Screen for sanctions before sending -->
                <try>
                    <swift:screen-transaction config-ref="SWIFT_Config"
                        screeningProvider="WORLDCHECK" />
                    
                    <choice>
                        <when expression="#[payload.passed]">
                            <logger level="INFO" message="Sanctions screening passed" />
                            
                            <!-- Send SWIFT message -->
                            <swift:send-message config-ref="SWIFT_Config"
                                messageType="MT103"
                                sender="${swift.bic}"
                                receiver="#[vars.originalPayload.receiver]"
                                format="MT"
                                priority="NORMAL" />
                            
                            <!-- Log audit trail -->
                            <swift:log-audit-trail config-ref="SWIFT_Config"
                                messageId="#[payload.messageId]"
                                operation="SEND"
                                metadata="#['correlationId=' ++ vars.correlationId]" />
                            
                            <!-- Build success response -->
                            <set-payload value="#[{
                                success: true,
                                messageId: payload.messageId,
                                sequenceNumber: attributes.sequenceNumber,
                                timestamp: attributes.timestamp as String,
                                correlationId: vars.correlationId,
                                status: 'SENT'
                            }]" />
                            <set-variable variableName="httpStatus" value="200" />
                        </when>
                        <otherwise>
                            <logger level="WARN" message="Payment blocked by sanctions screening" />
                            <set-payload value='{"error": "Payment blocked by sanctions screening", "matchCount": #[payload.matchCount]}' />
                            <set-variable variableName="httpStatus" value="403" />
                        </otherwise>
                    </choice>
                    
                    <error-handler>
                        <on-error-continue type="SWIFT:SANCTIONS_SCREENING_FAILED">
                            <set-payload value='{"error": "Sanctions screening failed"}' />
                            <set-variable variableName="httpStatus" value="500" />
                        </on-error-continue>
                    </error-handler>
                </try>
            </otherwise>
        </choice>
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
        <set-variable variableName="httpStatus" value="#[vars.httpStatus default 200]" />
    </flow>

    <!-- ==================================== -->
    <!-- API: Track gpi Payment               -->
    <!-- GET /api/payments/{uetr}/track      -->
    <!-- ==================================== -->
    <flow name="track-payment-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/payments/{uetr}/track" allowedMethods="GET" />
        
        <logger level="INFO" message="Tracking payment: #[attributes.uriParams.uetr]" />
        
        <!-- Track payment via gpi -->
        <swift:track-payment config-ref="SWIFT_Config"
            uetr="#[attributes.uriParams.uetr]" />
        
        <!-- Transform to JSON response -->
        <set-payload value="#[{
            uetr: payload.uetr,
            status: payload.status,
            currentLocation: payload.currentLocation,
            originatingBank: payload.originatingBank,
            beneficiaryBank: payload.beneficiaryBank,
            lastUpdate: payload.lastUpdateTime as String,
            trackingEvents: payload.trackingEvents map {
                institution: $.institution,
                status: $.status,
                timestamp: $.timestamp as String,
                remarks: $.remarks
            }
        }]" />
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ==================================== -->
    <!-- API: Validate Message                -->
    <!-- POST /api/validate                   -->
    <!-- ==================================== -->
    <flow name="validate-message-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/validate" allowedMethods="POST" />
        
        <logger level="INFO" message="Validating message: #[payload.messageType]" />
        
        <!-- âœ… NEW: Enhanced validation with categorized error handling -->
        <try>
            <!-- Validate schema with categorized error handling -->
            <swift:validate-schema config-ref="SWIFT_Config"
                messageType="#[payload.messageType]"
                format="#[payload.format default 'MT']"
                standardRelease="SR2024" />
            
            <!-- Transform response -->
            <set-payload value="#[{
                valid: payload.valid,
                messageType: payload.messageType,
                format: payload.format,
                standardRelease: payload.standardRelease,
                errors: payload.errors map {
                    code: $.code,
                    message: $.message,
                    field: $.field,
                    category: $.category
                },
                warnings: payload.warnings map {
                    code: $.code,
                    message: $.message,
                    field: $.field
                },
                timestamp: payload.validationTimestamp as String
            }]" />
            
            <error-handler>
                <!-- âœ… SYNTAX_ERROR: Malformed message (no retry) -->
                <on-error-continue type="SWIFT:SYNTAX_ERROR">
                    <logger level="ERROR" 
                        message="âŒ SYNTAX ERROR: Message is malformed - #[error.description]" 
                        category="com.mulesoft.swift.validation"/>
                    
                    <!-- Alert dev team (example: would send email/Slack in production) -->
                    <logger level="ERROR" 
                        message="ðŸš¨ DEV ALERT: Fix message format at source. No retry will be attempted." />
                    
                    <set-payload value="#[{
                        error: 'SYNTAX_ERROR',
                        message: error.description,
                        category: 'MALFORMED_MESSAGE',
                        retryable: false,
                        action: 'Contact development team to fix message format',
                        timestamp: now() as String
                    }]" />
                    <set-variable variableName="httpStatus" value="400" />
                </on-error-continue>
                
                <!-- âœ… BUSINESS_RULE_VIOLATION: Valid syntax but failed business rules (retry eligible) -->
                <on-error-continue type="SWIFT:BUSINESS_RULE_VIOLATION">
                    <logger level="WARN" 
                        message="âš ï¸ BUSINESS RULE VIOLATION: #[error.description]" 
                        category="com.mulesoft.swift.validation"/>
                    
                    <!-- Retry logic for business rule violations -->
                    <logger level="WARN" 
                        message="ðŸ’¡ BUSINESS ALERT: May be retried after correcting business data (e.g., cutoff time, holiday)" />
                    
                    <set-payload value="#[{
                        error: 'BUSINESS_RULE_VIOLATION',
                        message: error.description,
                        category: 'BUSINESS_LOGIC_FAILURE',
                        retryable: true,
                        action: 'Retry after business hours or on next business day',
                        timestamp: now() as String
                    }]" />
                    <set-variable variableName="httpStatus" value="422" />
                </on-error-continue>
            </error-handler>
        </try>
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ==================================== -->
    <!-- âœ… NEW: Sanctions Screening Demo     -->
    <!-- POST /api/screen                     -->
    <!-- Demonstrates BUSINESS_RULE_VIOLATION -->
    <!-- ==================================== -->
    <flow name="sanctions-screening-demo-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/screen" allowedMethods="POST" />
        
        <logger level="INFO" message="Screening transaction: #[payload]" />
        
        <try>
            <!-- Screen with production mode (will demonstrate error handling) -->
            <swift:screen-transaction config-ref="SWIFT_Config"
                screeningProvider="WORLDCHECK" />
            
            <!-- Success response -->
            <set-payload value="#[{
                passed: true,
                message: 'Transaction passed sanctions screening',
                timestamp: now() as String
            }]" />
            <set-variable variableName="httpStatus" value="200" />
            
            <error-handler>
                <!-- âœ… SANCTIONS_VIOLATION: Block transaction immediately -->
                <on-error-continue type="SWIFT:SANCTIONS_VIOLATION">
                    <logger level="ERROR" 
                        message="ðŸš« SANCTIONS VIOLATION: Transaction blocked - #[error.description]" 
                        category="com.mulesoft.swift.compliance"/>
                    
                    <!-- Alert compliance team -->
                    <logger level="ERROR" 
                        message="ðŸš¨ COMPLIANCE ALERT: Sanctions match detected. Transaction blocked. Manual review required." />
                    
                    <!-- Retry with backoff (may be transient false positive) -->
                    <until-successful maxRetries="2" millisBetweenRetries="300000">
                        <logger level="INFO" message="Retrying sanctions screening (attempt #[vars.retryCount + 1])..." />
                        <swift:screen-transaction config-ref="SWIFT_Config"
                            screeningProvider="WORLDCHECK" />
                    </until-successful>
                    
                    <set-payload value="#[{
                        error: 'SANCTIONS_VIOLATION',
                        message: error.description,
                        category: 'BUSINESS_RULE_VIOLATION',
                        retryable: true,
                        action: 'Manual compliance review required',
                        timestamp: now() as String
                    }]" />
                    <set-variable variableName="httpStatus" value="403" />
                </on-error-continue>
            </error-handler>
        </try>
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ==================================== -->
    <!-- API: Translate MT to MX              -->
    <!-- POST /api/translate/mt-to-mx         -->
    <!-- ==================================== -->
    <flow name="translate-mt-to-mx-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/translate/mt-to-mx" allowedMethods="POST" />
        
        <logger level="INFO" message="Translating MT to MX: #[payload.messageType]" />
        
        <!-- Translate -->
        <swift:translate-mt-to-mx config-ref="SWIFT_Config"
            mtMessageType="#[payload.messageType]" />
        
        <!-- Transform response -->
        <set-payload value="#[{
            success: payload.success,
            sourceFormat: payload.sourceFormat,
            targetFormat: payload.targetFormat,
            mtMessageType: payload.mtMessageType,
            mxMessageType: payload.mxMessageType,
            translatedContent: payload.translatedContent,
            timestamp: payload.translationTimestamp as String
        }]" />
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ==================================== -->
    <!-- API: Lookup BIC Code                 -->
    <!-- GET /api/bic/{bicCode}               -->
    <!-- ==================================== -->
    <flow name="lookup-bic-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/bic/{bicCode}" allowedMethods="GET" />
        
        <logger level="INFO" message="Looking up BIC: #[attributes.uriParams.bicCode]" />
        
        <!-- Lookup BIC -->
        <swift:lookup-bic-code config-ref="SWIFT_Config"
            bicCode="#[attributes.uriParams.bicCode]" />
        
        <!-- Transform response -->
        <set-payload value="#[{
            bicCode: payload.bicCode,
            valid: payload.valid,
            institutionName: payload.institutionName,
            branchInformation: payload.branchInformation,
            countryCode: payload.countryCode,
            city: payload.city,
            active: payload.active
        }]" />
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ==================================== -->
    <!-- API: Check Holiday Calendar          -->
    <!-- GET /api/holidays/{date}/{calendar}  -->
    <!-- ==================================== -->
    <flow name="check-holiday-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/holidays/{date}/{calendar}" allowedMethods="GET" />
        
        <logger level="INFO" message="Checking holiday: #[attributes.uriParams.date] on #[attributes.uriParams.calendar]" />
        
        <!-- Check holiday -->
        <swift:check-holiday config-ref="SWIFT_Config"
            valueDate="#[attributes.uriParams.date]"
            calendar="#[attributes.uriParams.calendar]" />
        
        <!-- Transform response -->
        <set-payload value="#[{
            date: payload.valueDate as String,
            calendar: payload.calendar,
            isHoliday: payload.holiday,
            isBusinessDay: payload.businessDay,
            holidayName: payload.holidayName
        }]" />
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ==================================== -->
    <!-- API: Get Metrics                     -->
    <!-- GET /api/metrics                     -->
    <!-- ==================================== -->
    <flow name="get-metrics-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/metrics" allowedMethods="GET" />
        
        <logger level="INFO" message="Retrieving metrics" />
        
        <!-- Get metrics -->
        <swift:get-metrics config-ref="SWIFT_Config" />
        
        <!-- Transform response -->
        <set-payload value="#[{
            messagesSent: payload.messagesSent,
            messagesReceived: payload.messagesReceived,
            messagesFailed: payload.messagesFailed,
            averageLatencyMs: payload.averageLatencyMs,
            successRate: payload.successRate,
            timestamp: payload.collectionTimestamp as String
        }]" />
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ==================================== -->
    <!-- API: Health Check                    -->
    <!-- GET /api/health                      -->
    <!-- ==================================== -->
    <flow name="health-check-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/health" allowedMethods="GET" />
        
        <logger level="INFO" message="Health check requested" />
        
        <!-- Get session info -->
        <swift:get-session-info config-ref="SWIFT_Config" />
        
        <!-- Transform response -->
        <set-payload value="#[{
            status: 'UP',
            swift: {
                connected: payload.connected,
                sessionActive: payload.active,
                sessionId: payload.sessionId,
                inputSequence: payload.inputSequenceNumber,
                outputSequence: payload.outputSequenceNumber,
                connectionTime: payload.connectionTimestamp
            },
            timestamp: now() as String
        }]" />
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ==================================== -->
    <!-- Listener: Incoming SWIFT Messages    -->
    <!-- Triggered automatically               -->
    <!-- ==================================== -->
    <flow name="receive-swift-messages-flow">
        <swift:listener config-ref="SWIFT_Config"
            pollingInterval="5000"
            messageTypeFilter="MT103" />
        
        <logger level="INFO" message="Received SWIFT message: #[attributes.messageId] from #[payload.sender]" />
        
        <!-- Log the message -->
        <logger level="INFO" message="Message Type: #[payload.messageType], Content: #[payload.content]" />
        
        <!-- Send acknowledgment -->
        <swift:acknowledge-message config-ref="SWIFT_Config"
            messageId="#[attributes.messageId]"
            acknowledgeType="ACK" />
        
        <logger level="INFO" message="Acknowledgment sent for message #[attributes.messageId]" />
        
        <!-- Process the payment (your business logic here) -->
        <logger level="INFO" message="Processing payment..." />
    </flow>

    <!-- ============================================================ -->
    <!-- âœ… PRODUCTION PATTERN 1: File Polling (Asynchronous)        -->
    <!-- Demonstrates realistic SWIFT integration via file drop       -->
    <!-- Simulates: Bank SFTP â†’ File Poller â†’ SWIFT Connector        -->
    <!-- ============================================================ -->
    <flow name="file-polling-mt103-flow" initialState="started">
        <file:listener config-ref="File_Config" 
            directory="inbox"
            autoDelete="false"
            moveToDirectory="processed"
            recursive="false">
            <scheduling-strategy>
                <fixed-frequency frequency="5000"/> <!-- Poll every 5 seconds -->
            </scheduling-strategy>
            <file:matcher filenamePattern="*.mt103" />
        </file:listener>
        
        <logger level="INFO" message="ðŸ“ File detected: #[attributes.fileName] (Size: #[attributes.size] bytes)" 
            category="com.mulesoft.swift.filepoller"/>
        
        <set-variable variableName="originalFileName" value="#[attributes.fileName]" />
        <set-variable variableName="fileTimestamp" value="#[now()]" />
        
        <!-- Parse file content as MT103 -->
        <set-payload value="#[payload]" encoding="UTF-8" />
        
        <try>
            <!-- âœ… STEP 1: Pre-Validate Message (BEFORE sending to SWIFT) -->
            <logger level="INFO" message="ðŸ” Pre-validating MT103 message..." />
            
            <swift:validate-schema config-ref="SWIFT_Config"
                messageType="MT103"
                format="MT"
                standardRelease="SR2024" />
            
            <logger level="INFO" message="âœ… Validation passed: #[payload.valid]" />
            
            <!-- âœ… STEP 2: Extract Multi-Block Data (Block 1, 3, 4) -->
            <ee:transform>
                <ee:message>
                    <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    // Extract Block 1 (Basic Header) - Institution identification
    block1: do {
        var block1Match = payload match /\{1:(.*?)\}/
        ---
        if (block1Match != null) block1Match[1] else null
    },
    
    // Extract Block 3 (User Header) - UETR for end-to-end tracking
    block3: do {
        var block3Match = payload match /\{3:(.*?)\}/
        var uetrMatch = payload match /:121:([0-9a-f\-]{36})/
        ---
        {
            raw: if (block3Match != null) block3Match[1] else null,
            uetr: if (uetrMatch != null) uetrMatch[1] else null
        }
    },
    
    // Extract Block 4 (Message Body) - Payment details
    block4: do {
        var ref = payload match /:20:(.*?)[\n:]/
        var amount = payload match /:32A:(\d{6})([A-Z]{3})([\d,\.]+)/
        var ordering = payload match /:50K:(.*?)(?=:\d{2}[A-Z]?:|$)/
        var beneficiary = payload match /:59:(.*?)(?=:\d{2}[A-Z]?:|$)/
        ---
        {
            reference: if (ref != null) ref[1] else null,
            valueDate: if (amount != null) amount[1] else null,
            currency: if (amount != null) amount[2] else null,
            amount: if (amount != null) amount[3] else null,
            orderingCustomer: if (ordering != null) ordering[1] else null,
            beneficiary: if (beneficiary != null) beneficiary[1] else null
        }
    },
    
    fileName: vars.originalFileName,
    processedAt: vars.fileTimestamp as String
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>
            
            <logger level="INFO" message="ðŸ“‹ Extracted Data - Ref: #[payload.block4.reference], Amount: #[payload.block4.currency] #[payload.block4.amount], UETR: #[payload.block3.uetr]" />
            
            <!-- âœ… STEP 3: Send to SWIFT Network -->
            <set-variable variableName="parsedPayload" value="#[payload]" />
            
            <swift:send-message config-ref="SWIFT_Config"
                messageType="MT103"
                sender="${swift.bic}"
                receiver="BANKDE33XXX"
                format="MT"
                priority="NORMAL" />
            
            <logger level="INFO" message="âœ… Message sent: #[payload.messageId], Sequence: #[attributes.sequenceNumber]" />
            
            <!-- Write success audit log -->
            <file:write config-ref="File_Config"
                path="audit/#[vars.originalFileName].success.json">
                <file:content><![CDATA[#[output application/json --- {
                    fileName: vars.originalFileName,
                    messageId: payload.messageId,
                    sequenceNumber: attributes.sequenceNumber,
                    uetr: vars.parsedPayload.block3.uetr,
                    reference: vars.parsedPayload.block4.reference,
                    amount: vars.parsedPayload.block4.amount,
                    currency: vars.parsedPayload.block4.currency,
                    status: "SENT",
                    timestamp: now() as String
                }]]]></file:content>
            </file:write>
            
            <error-handler>
                <!-- âœ… SYNTAX_ERROR: Message validation failed -->
                <on-error-continue type="SWIFT:SYNTAX_ERROR">
                    <logger level="ERROR" 
                        message="âŒ VALIDATION FAILED for #[vars.originalFileName]: #[error.description]" 
                        category="com.mulesoft.swift.filepoller"/>
                    
                    <!-- Move to error folder with reason -->
                    <file:write config-ref="File_Config"
                        path="error/#[vars.originalFileName].error.json">
                        <file:content><![CDATA[#[output application/json --- {
                            fileName: vars.originalFileName,
                            errorType: "SYNTAX_ERROR",
                            errorMessage: error.description,
                            action: "Fix message format and resubmit",
                            timestamp: now() as String
                        }]]]></file:content>
                    </file:write>
                    
                    <!-- Alert operations team -->
                    <logger level="ERROR" message="ðŸš¨ File moved to error folder: #[vars.originalFileName]" />
                </on-error-continue>
                
                <!-- âœ… NACK_RECEIVED: SWIFT network rejected -->
                <on-error-continue type="SWIFT:NACK_RECEIVED">
                    <logger level="ERROR" 
                        message="âŒ NACK RECEIVED for #[vars.originalFileName]: #[error.description]" 
                        category="com.mulesoft.swift.filepoller"/>
                    
                    <!-- Parse NACK reason code -->
                    <swift:parse-reject-code config-ref="SWIFT_Config"
                        rejectCode="K90"
                        messageId="#[vars.originalFileName]" />
                    
                    <file:write config-ref="File_Config"
                        path="nack/#[vars.originalFileName].nack.json">
                        <file:content><![CDATA[#[output application/json --- {
                            fileName: vars.originalFileName,
                            errorType: "NACK_RECEIVED",
                            rejectCode: payload.rejectCode,
                            description: payload.description,
                            recoverable: payload.recoverable,
                            suggestedAction: payload.suggestedAction,
                            timestamp: now() as String
                        }]]]></file:content>
                    </file:write>
                </on-error-continue>
            </error-handler>
        </try>
    </flow>

    <!-- ============================================================ -->
    <!-- âœ… PRODUCTION PATTERN 2: Pre-Validation Flow                -->
    <!-- Validate-only endpoint (no transmission to SWIFT)           -->
    <!-- Use Case: Pre-flight check before sending high-value txns   -->
    <!-- ============================================================ -->
    <flow name="validation-only-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/validate-only" allowedMethods="POST" />
        
        <logger level="INFO" message="ðŸ” Validation-only request: #[payload.messageType]" />
        
        <try>
            <!-- Validate without sending -->
            <swift:validate-schema config-ref="SWIFT_Config"
                messageType="#[payload.messageType]"
                format="#[payload.format default 'MT']"
                standardRelease="SR2024" />
            
            <!-- âœ… Additional Business Rule Validation -->
            <choice>
                <when expression="#[payload.messageType == 'MT103']">
                    <!-- Extract amount and check limits -->
                    <set-variable variableName="amount" 
                        value="#[payload.messageContent match /:32A:\d{6}[A-Z]{3}([\d,\.]+)/ default ['0']][0]" />
                    
                    <choice>
                        <when expression="#[vars.amount as Number > 1000000]">
                            <raise-error type="MULE:VALIDATION" 
                                description="High-value payment (>1M) requires additional approval" />
                        </when>
                    </choice>
                </when>
            </choice>
            
            <!-- Transform to structured response -->
            <ee:transform>
                <ee:message>
                    <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    validationStatus: "PASSED",
    messageType: payload.messageType,
    format: payload.format,
    standardRelease: payload.standardRelease,
    errors: payload.errors map {
        code: $.code,
        message: $.message,
        field: $.field,
        category: $.category
    },
    warnings: payload.warnings map {
        code: $.code,
        message: $.message
    },
    readyToSend: payload.valid,
    timestamp: now() as String
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>
            
            <set-variable variableName="httpStatus" value="200" />
            
            <error-handler>
                <on-error-continue type="SWIFT:SYNTAX_ERROR">
                    <ee:transform>
                        <ee:message>
                            <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    validationStatus: "FAILED",
    errorCategory: "SYNTAX_ERROR",
    errorMessage: error.description,
    readyToSend: false,
    action: "Fix message format before sending to SWIFT network",
    timestamp: now() as String
}]]></ee:set-payload>
                        </ee:message>
                    </ee:transform>
                    <set-variable variableName="httpStatus" value="400" />
                </on-error-continue>
                
                <on-error-continue type="SWIFT:BUSINESS_RULE_VIOLATION">
                    <ee:transform>
                        <ee:message>
                            <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    validationStatus: "FAILED",
    errorCategory: "BUSINESS_RULE_VIOLATION",
    errorMessage: error.description,
    readyToSend: false,
    retryEligible: true,
    action: "Correct business data (e.g., amount, approval) and retry",
    timestamp: now() as String
}]]></ee:set-payload>
                        </ee:message>
                    </ee:transform>
                    <set-variable variableName="httpStatus" value="422" />
                </on-error-continue>
            </error-handler>
        </try>
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ============================================================ -->
    <!-- âœ… PRODUCTION PATTERN 3: ISO 20022 (MX) Transformation      -->
    <!-- MT-to-MX conversion for ISO 20022 migration                  -->
    <!-- Demonstrates: Legacy MT103 â†’ Modern pacs.008 XML             -->
    <!-- ============================================================ -->
    <flow name="mt-to-mx-conversion-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/transform/mt-to-mx" allowedMethods="POST" />
        
        <logger level="INFO" message="ðŸ”„ MT-to-MX conversion requested: #[payload.mtMessageType]" />
        
        <set-variable variableName="originalMtContent" value="#[payload.mtContent]" />
        
        <!-- Translate MT to MX -->
        <swift:translate-mt-to-mx config-ref="SWIFT_Config"
            mtMessageType="#[payload.mtMessageType]" />
        
        <logger level="INFO" message="âœ… Translated: #[payload.mtMessageType] â†’ #[payload.mxMessageType]" />
        
        <!-- âœ… DataWeave Metadata Demo: Parse MX XML and extract structured data -->
        <ee:transform>
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
input payload application/xml
---
{
    conversionSummary: {
        sourceFormat: "MT",
        targetFormat: "MX",
        mtMessageType: payload.mtMessageType,
        mxMessageType: payload.mxMessageType,
        translationSuccess: payload.success,
        timestamp: payload.translationTimestamp
    },
    
    // âœ… Demonstrate MX XML parsing (ISO 20022 structure)
    mxStructure: do {
        var mxXml = read(payload.translatedContent, "application/xml")
        ---
        {
            documentType: mxXml.Document.@xmlns,
            messageId: mxXml.Document.*GrpHdr.MsgId default "N/A",
            creationDateTime: mxXml.Document.*GrpHdr.CreDtTm default "N/A",
            numberOfTransactions: mxXml.Document.*GrpHdr.NbOfTxs default "0",
            
            // Extract payment details (demonstrates drag-and-drop metadata)
            paymentInfo: mxXml.Document.*CdtTrfTxInf map {
                paymentId: $.PmtId.InstrId,
                instructedAmount: $.IntrBkSttlmAmt.@Ccy ++ " " ++ $.IntrBkSttlmAmt,
                debtor: $.Dbtr.Nm,
                creditor: $.Cdtr.Nm
            }
        }
    },
    
    // Original MT content for comparison
    originalMT: vars.originalMtContent,
    
    // Full MX XML
    mxXml: payload.translatedContent
}]]></ee:set-payload>
            </ee:message>
        </ee:transform>
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ============================================================ -->
    <!-- âœ… PRODUCTION PATTERN 4: MX-to-JSON Parsing                 -->
    <!-- Parse ISO 20022 XML into JSON for modern systems             -->
    <!-- Demonstrates: pacs.008 XML â†’ JSON API response               -->
    <!-- ============================================================ -->
    <flow name="mx-to-json-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/parse/mx-to-json" allowedMethods="POST" />
        
        <logger level="INFO" message="ðŸ“„ MX-to-JSON parsing requested" />
        
        <!-- âœ… Advanced DataWeave: Parse complex ISO 20022 XML structure -->
        <ee:transform>
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
input payload application/xml
---
{
    messageType: "ISO20022_pacs.008",
    parsedAt: now() as String,
    
    // Group Header
    groupHeader: {
        messageId: payload.Document.*GrpHdr.MsgId,
        creationDateTime: payload.Document.*GrpHdr.CreDtTm,
        numberOfTransactions: payload.Document.*GrpHdr.NbOfTxs as Number,
        settlementInformation: {
            method: payload.Document.*GrpHdr.SttlmInf.SttlmMtd,
            account: payload.Document.*GrpHdr.SttlmInf.SttlmAcct.Id.IBAN default "N/A"
        }
    },
    
    // Credit Transfer Transaction Information (array of payments)
    transactions: payload.Document.*CdtTrfTxInf map {
        paymentIdentification: {
            instructionId: $.PmtId.InstrId,
            endToEndId: $.PmtId.EndToEndId,
            transactionId: $.PmtId.TxId,
            uetr: $.PmtId.UETR default null // Unique End-to-end Transaction Reference
        },
        
        settlementAmount: {
            currency: $.IntrBkSttlmAmt.@Ccy,
            amount: $.IntrBkSttlmAmt as Number
        },
        
        valueDate: $.IntrBkSttlmDt,
        
        debtor: {
            name: $.Dbtr.Nm,
            account: $.DbtrAcct.Id.IBAN default $.DbtrAcct.Id.Othr.Id default "N/A",
            agent: {
                bic: $.DbtrAgt.FinInstnId.BICFI default "N/A",
                name: $.DbtrAgt.FinInstnId.Nm default "N/A"
            }
        },
        
        creditor: {
            name: $.Cdtr.Nm,
            account: $.CdtrAcct.Id.IBAN default $.CdtrAcct.Id.Othr.Id default "N/A",
            agent: {
                bic: $.CdtrAgt.FinInstnId.BICFI default "N/A",
                name: $.CdtrAgt.FinInstnId.Nm default "N/A"
            }
        },
        
        remittanceInformation: {
            unstructured: $.RmtInf.Ustrd[0] default null,
            structured: $.RmtInf.Strd.CdtrRefInf.Ref default null
        },
        
        charges: {
            bearer: $.ChrgBr default "SHAR", // Shared charges
            details: $.ChrgsInf map {
                amount: $.Amt.@Ccy ++ " " ++ $.Amt,
                agent: $.Agt.FinInstnId.BICFI default "N/A"
            }
        }
    },
    
    // Metadata for tracking
    metadata: {
        totalTransactions: sizeOf(payload.Document.*CdtTrfTxInf),
        totalAmount: sum(payload.Document.*CdtTrfTxInf.*IntrBkSttlmAmt map $ as Number),
        currencies: (payload.Document.*CdtTrfTxInf.*IntrBkSttlmAmt.@Ccy) distinctBy $,
        processingMode: "ISO20022_NATIVE"
    }
}]]></ee:set-payload>
            </ee:message>
        </ee:transform>
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ============================================================ -->
    <!-- âœ… PRODUCTION PATTERN 5: NACK Error Mapping                 -->
    <!-- Parse SWIFT NACK codes and map to human-readable reasons    -->
    <!-- Demonstrates: Reject code â†’ Actionable remediation          -->
    <!-- ============================================================ -->
    <flow name="nack-error-mapping-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/nack/parse" allowedMethods="POST" />
        
        <logger level="INFO" message="ðŸ” Parsing NACK code: #[payload.rejectCode]" />
        
        <!-- Parse reject code using connector's dictionary -->
        <swift:parse-reject-code config-ref="SWIFT_Config"
            rejectCode="#[payload.rejectCode]"
            messageId="#[payload.messageId default uuid()]" />
        
        <!-- âœ… Map to actionable response with remediation steps -->
        <ee:transform>
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    rejectCode: payload.rejectCode,
    severity: payload.category,
    description: payload.description,
    isRecoverable: payload.recoverable,
    
    // âœ… Actionable Remediation Mapping
    remediation: do {
        var code = payload.rejectCode
        ---
        if (code startsWith "K") {
            // K-series: Message format errors
            {
                category: "FORMAT_ERROR",
                action: payload.suggestedAction,
                retryRecommendation: "Fix message format and resubmit",
                alertTeam: "Development Team",
                sla: "Fix within 2 hours"
            }
        } else if (code startsWith "D") {
            // D-series: Delivery errors
            {
                category: "DELIVERY_ERROR",
                action: "Check network connectivity and recipient BIC",
                retryRecommendation: "Retry after verifying recipient details",
                alertTeam: "Operations Team",
                sla: "Retry within 30 minutes"
            }
        } else if (code startsWith "S") {
            // S-series: Security/authentication errors
            {
                category: "SECURITY_ERROR",
                action: "Verify digital signature and LAU credentials",
                retryRecommendation: "Re-authenticate and retry",
                alertTeam: "Security Team",
                sla: "Investigate immediately"
            }
        } else {
            {
                category: "UNKNOWN_ERROR",
                action: payload.suggestedAction,
                retryRecommendation: "Contact SWIFT support",
                alertTeam: "SWIFT Operations",
                sla: "Escalate within 1 hour"
            }
        }
    },
    
    // Provide historical context (mock data for demo)
    historicalData: {
        occurenceCount: 0, // Would query from database
        lastOccurrence: null,
        commonCause: "Field :32A format incorrect (date must be YYMMDD)"
    },
    
    timestamp: now() as String
}]]></ee:set-payload>
            </ee:message>
        </ee:transform>
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

    <!-- ============================================================ -->
    <!-- âœ… PRODUCTION PATTERN 6: Multi-Block Message Handling       -->
    <!-- Extract and process all 5 SWIFT blocks                      -->
    <!-- Demonstrates: Complete SWIFT FIN message parsing             -->
    <!-- ============================================================ -->
    <flow name="multi-block-parsing-flow">
        <http:listener config-ref="HTTP_Listener_config" path="/api/parse/multi-block" allowedMethods="POST" />
        
        <logger level="INFO" message="ðŸ“‹ Multi-block parsing requested" />
        
        <!-- âœ… Extract all 5 SWIFT blocks using DataWeave regex -->
        <ee:transform>
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    messageType: "FIN_MT103",
    
    // Block 1: Basic Header (Institution Identification)
    block1_basicHeader: do {
        var match = payload match /\{1:(.*?)\}/
        var content = if (match != null) match[1] else null
        ---
        {
            raw: content,
            applicationId: content[0 to 0],      // F = FIN
            serviceId: content[1 to 2],           // 01 = FIN Service
            logicalTerminal: content[3 to 14],    // BIC + LT identifier
            sessionNumber: content[15 to 18],
            sequenceNumber: content[19 to 24]
        }
    },
    
    // Block 2: Application Header (Message Routing)
    block2_applicationHeader: do {
        var match = payload match /\{2:(.*?)\}/
        var content = if (match != null) match[1] else null
        ---
        {
            raw: content,
            ioIdentifier: content[0 to 0],         // I = Input, O = Output
            messageType: content[1 to 3],          // 103 = Single Customer Credit
            destinationBic: content[4 to 15],
            priority: content[16 to 16],           // N = Normal, U = Urgent
            deliveryMonitoring: content[17 to 17] default null
        }
    },
    
    // Block 3: User Header (Optional - UETR, Validation Flags)
    block3_userHeader: do {
        var match = payload match /\{3:(.*?)\}/
        var content = if (match != null) match[1] else null
        var uetrMatch = content match /:121:([0-9a-f\-]{36})/
        var priorityMatch = content match /:103:([A-Z]{3})/
        ---
        {
            raw: content,
            uetr: if (uetrMatch != null) uetrMatch[1] else null,      // Unique End-to-end Transaction Reference
            serviceType: if (priorityMatch != null) priorityMatch[1] else null,
            validationFlag: content match /:119:/ != null             // STP validation
        }
    },
    
    // Block 4: Text (Message Body - Payment Details)
    block4_textBlock: do {
        var match = payload match /\{4:(.*?)-\}/
        var content = if (match != null) match[1] else null
        ---
        {
            raw: content,
            fields: {
                transactionReference: (content match /:20:(.*?)[\n:]/)[1] default null,
                bankOperationCode: (content match /:23B:(.*?)[\n:]/)[1] default null,
                valueDate: (content match /:32A:(\d{6})/)[1] default null,
                currency: (content match /:32A:\d{6}([A-Z]{3})/)[1] default null,
                amount: (content match /:32A:\d{6}[A-Z]{3}([\d,\.]+)/)[1] default null,
                orderingCustomer: (content match /:50K:(.*?)(?=:\d{2}[A-Z]?:|$)/)[1] default null,
                beneficiary: (content match /:59:(.*?)(?=:\d{2}[A-Z]?:|$)/)[1] default null,
                remittanceInfo: (content match /:70:(.*?)(?=:\d{2}[A-Z]?:|$)/)[1] default null
            }
        }
    },
    
    // Block 5: Trailer (System Information - MAC, Checksum)
    block5_trailer: do {
        var match = payload match /\{5:(.*?)\}/
        var content = if (match != null) match[1] else null
        var macMatch = content match /\{MAC:([A-F0-9]+)\}/
        var chkMatch = content match /\{CHK:([A-F0-9]+)\}/
        ---
        {
            raw: content,
            mac: if (macMatch != null) macMatch[1] else null,         // Message Authentication Code
            checksum: if (chkMatch != null) chkMatch[1] else null,    // Checksum for integrity
            possibleDuplicateEmission: content match /\{PDE/ != null,
            messageReference: (content match /\{MRF:(\d+)\}/)[1] default null
        }
    },
    
    // Validation Summary
    validation: {
        allBlocksPresent: payload contains "{1:" and payload contains "{2:" and payload contains "{4:",
        hasUETR: payload contains ":121:",
        hasMAC: payload contains "{MAC:",
        messageIntegrity: "VALID" // Would verify MAC/CHK in production
    },
    
    timestamp: now() as String
}]]></ee:set-payload>
            </ee:message>
        </ee:transform>
        
        <set-payload value="#[output application/json --- payload]" mimeType="application/json" />
    </flow>

</mule>

